"use strict";(self.webpackChunkotai_documentation=self.webpackChunkotai_documentation||[]).push([[1377],{7374:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"features/plugin/functions/tab-shared/Common","title":"Common","description":"Shared Function Components","source":"@site/docs/features/plugin/functions/tab-shared/Common.md","sourceDirName":"features/plugin/functions/tab-shared","slug":"/features/plugin/functions/tab-shared/Common","permalink":"/open-tutor-ai-docs/docs/features/plugin/functions/tab-shared/Common","draft":false,"unlisted":false,"editUrl":"https://github.com/pr-elhajji/open-tutor-ai-CE/docs/features/plugin/functions/tab-shared/Common.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\ud83c\udfac Action Function","permalink":"/open-tutor-ai-docs/docs/features/plugin/functions/action"},"next":{"title":"\u2699\ufe0f Tools","permalink":"/open-tutor-ai-docs/docs/features/plugin/tools/"}}');var a=n(4848),i=n(8453);const o={},r=void 0,l={},d=[{value:"Shared Function Components",id:"shared-function-components",level:2},{value:"Valves and UserValves - (optional, but HIGHLY encouraged)",id:"valves-and-uservalves---optional-but-highly-encouraged",level:3},{value:"Event Emitters",id:"event-emitters",level:3},{value:"Status",id:"status",level:4},{value:"Message",id:"message",level:4}];function c(e){const t={code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,i.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"shared-function-components",children:"Shared Function Components"}),"\n",(0,a.jsx)(t.h3,{id:"valves-and-uservalves---optional-but-highly-encouraged",children:"Valves and UserValves - (optional, but HIGHLY encouraged)"}),"\n",(0,a.jsx)(t.p,{children:"Valves and UserValves are used to allow users to provide dynamic details such as an API key or a configuration option. These will create a fillable field or a bool switch in the GUI menu for the given function."}),"\n",(0,a.jsx)(t.p,{children:"Valves are configurable by admins alone and UserValves are configurable by any users."}),"\n",(0,a.jsxs)(n,{children:[(0,a.jsx)("summary",{children:"Example"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'# Define and Valves\n    class Valves(BaseModel):\n        priority: int = Field(\n            default=0, description="Priority level for the filter operations."\n        )\n        test_valve: int = Field(\n            default=4, description="A valve controlling a numerical value"\n        )\n        pass\n\n    # Define any UserValves\n    class UserValves(BaseModel):\n        test_user_valve: bool = Field(\n            default=False, description="A user valve controlling a True/False (on/off) switch"\n        )\n        pass\n\n    def __init__(self):\n        self.valves = self.Valves()\n        pass\n'})})]}),"\n",(0,a.jsx)(t.h3,{id:"event-emitters",children:"Event Emitters"}),"\n",(0,a.jsx)(t.p,{children:"Event Emitters are used to add additional information to the chat interface. Similarly to Filter Outlets, Event Emitters are capable of appending content to the chat. Unlike Filter Outlets, they are not capable of stripping information. Additionally, emitters can be activated at any stage during the function."}),"\n",(0,a.jsx)(t.p,{children:"There are two different types of Event Emitters:"}),"\n",(0,a.jsx)(t.h4,{id:"status",children:"Status"}),"\n",(0,a.jsx)(t.p,{children:"This is used to add statuses to a message while it is performing steps. These can be done at any stage during the Function. These statuses appear right above the message content. These are very useful for Functions that delay the LLM response or process large amounts of information. This allows you to inform users what is being processed in real-time."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'await __event_emitter__(\n            {\n                "type": "status", # We set the type here\n                "data": {"description": "Message that shows up in the chat", "done": False}, \n                # Note done is False here indicating we are still emitting statuses\n            }\n        )\n'})}),"\n",(0,a.jsxs)(n,{children:[(0,a.jsx)("summary",{children:"Example"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'async def test_function(\n        self, prompt: str, __user__: dict, __event_emitter__=None\n    ) -> str:\n        """\n        This is a demo\n\n        :param test: this is a test parameter\n        """\n\n        await __event_emitter__(\n            {\n                "type": "status", # We set the type here\n                "data": {"description": "Message that shows up in the chat", "done": False}, \n                # Note done is False here indicating we are still emitting statuses\n            }\n        )\n\n        # Do some other logic here\n        await __event_emitter__(\n            {\n                "type": "status",\n                "data": {"description": "Completed a task message", "done": True},\n                # Note done is True here indicating we are done emitting statuses\n            }\n        )\n\n        except Exception as e:\n            await __event_emitter__(\n                {\n                    "type": "status",\n                    "data": {"description": f"An error occured: {e}", "done": True},\n                }\n            )\n\n            return f"Tell the user: {e}"\n'})})]}),"\n",(0,a.jsx)(t.h4,{id:"message",children:"Message"}),"\n",(0,a.jsx)(t.p,{children:"This type is used to append a message to the LLM at any stage in the Function. This means that you can append messages, embed images, and even render web pages before, or after, or during the LLM response."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'await __event_emitter__(\n                    {\n                        "type": "message", # We set the type here\n                        "data": {"content": "This message will be appended to the chat."},\n                        # Note that with message types we do NOT have to set a done condition\n                    }\n                )\n'})}),"\n",(0,a.jsxs)(n,{children:[(0,a.jsx)("summary",{children:"Example"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'async def test_function(\n        self, prompt: str, __user__: dict, __event_emitter__=None\n    ) -> str:\n        """\n        This is a demo\n\n        :param test: this is a test parameter\n        """\n\n        await __event_emitter__(\n                    {\n                        "type": "message", # We set the type here\n                        "data": {"content": "This message will be appended to the chat."},\n                        # Note that with message types we do NOT have to set a done condition\n                    }\n                )\n\n        except Exception as e:\n            await __event_emitter__(\n                {\n                    "type": "status",\n                    "data": {"description": f"An error occured: {e}", "done": True},\n                }\n            )\n\n            return f"Tell the user: {e}"\n'})})]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(6540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);